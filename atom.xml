<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hupenghui123.top/"/>
  <updated>2018-09-01T15:56:00.010Z</updated>
  <id>http://hupenghui123.top/</id>
  
  <author>
    <name>HPH</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>检测到目标URL存在框架注入漏洞（即点击劫持）</title>
    <link href="http://hupenghui123.top/2018/09/01/%E6%A3%80%E6%B5%8B%E5%88%B0%E7%9B%AE%E6%A0%87URL%E5%AD%98%E5%9C%A8%E6%A1%86%E6%9E%B6%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88%E5%8D%B3%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81%EF%BC%89/"/>
    <id>http://hupenghui123.top/2018/09/01/检测到目标URL存在框架注入漏洞（即点击劫持）/</id>
    <published>2018-09-01T13:14:45.000Z</published>
    <updated>2018-09-01T15:56:00.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞描述："><a href="#漏洞描述：" class="headerlink" title="漏洞描述："></a>漏洞描述：</h2><p>攻击者有可能注入含有恶意内容的 frame 或 iframe 标记。如果用户不够谨慎，就有可能浏览该标记，却意识不到自己会离开原始站点而进入恶意的站点。之后，攻击者便可以诱导用户再次登录，然后获取其登录凭证。</p><a id="more"></a><h2 id="修复方式："><a href="#修复方式：" class="headerlink" title="修复方式："></a>修复方式：</h2><h3 id="一：在前端页面：当在页面触发点击跳转事件是校验是否点击的窗口在自己的框架中，从而禁止攻击者注入自己的iframe窃取用户的信息"><a href="#一：在前端页面：当在页面触发点击跳转事件是校验是否点击的窗口在自己的框架中，从而禁止攻击者注入自己的iframe窃取用户的信息" class="headerlink" title="一：在前端页面：当在页面触发点击跳转事件是校验是否点击的窗口在自己的框架中，从而禁止攻击者注入自己的iframe窃取用户的信息"></a>一：在前端页面：当在页面触发点击跳转事件是校验是否点击的窗口在自己的框架中，从而禁止攻击者注入自己的iframe窃取用户的信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*注册用户离开当前页面跳往其他页面时触发该事件*/</span><br><span class="line"></span><br><span class="line">window.onbeforeunload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">setTimeout(beforeloadResult, 50)&#125;</span><br><span class="line">, 50);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">beforeloadResult</span></span> () &#123;</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"你取消了离开网页！"</span>);</span><br><span class="line">console.log(<span class="string">"这里可以做一些其他操作，比如恢复！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或：</span><br><span class="line"></span><br><span class="line">/*页面一开始就检验当前页面是否是顶层窗口，如果不是，</span><br><span class="line">就将当前页面所在的窗口设置为顶层窗口，从而防止别的网站把你自己的网站放在他的Iframe中*/</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(top!=window)&#123;</span><br><span class="line"></span><br><span class="line">top.location=window.location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二：Nginx-配置X-Frame-Options"><a href="#二：Nginx-配置X-Frame-Options" class="headerlink" title="二：Nginx 配置X-Frame-Options"></a>二：Nginx 配置X-Frame-Options</h3><p>到 nginx/conf文件夹下，修改nginx.conf ，添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//配置proxy_pass的下面</span><br><span class="line">add_header X-Frame-Options <span class="string">"SAMEORIGIN"</span>;</span><br></pre></td></tr></table></figure><p>重启Nginx服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;漏洞描述：&quot;&gt;&lt;a href=&quot;#漏洞描述：&quot; class=&quot;headerlink&quot; title=&quot;漏洞描述：&quot;&gt;&lt;/a&gt;漏洞描述：&lt;/h2&gt;&lt;p&gt;攻击者有可能注入含有恶意内容的 frame 或 iframe 标记。如果用户不够谨慎，就有可能浏览该标记，却意识不到自己会离开原始站点而进入恶意的站点。之后，攻击者便可以诱导用户再次登录，然后获取其登录凭证。&lt;/p&gt;
    
    </summary>
    
      <category term="WEB安全" scheme="http://hupenghui123.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="漏洞" scheme="http://hupenghui123.top/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="WEB安全" scheme="http://hupenghui123.top/tags/WEB%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>检测到目标URL存在http host头攻击漏洞</title>
    <link href="http://hupenghui123.top/2018/09/01/%E6%A3%80%E6%B5%8B%E5%88%B0%E7%9B%AE%E6%A0%87URL%E5%AD%98%E5%9C%A8http-host%E5%A4%B4%E6%94%BB%E5%87%BB%E6%BC%8F%E6%B4%9E/"/>
    <id>http://hupenghui123.top/2018/09/01/检测到目标URL存在http-host头攻击漏洞/</id>
    <published>2018-09-01T13:03:39.000Z</published>
    <updated>2018-09-06T12:26:26.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞描述："><a href="#漏洞描述：" class="headerlink" title="漏洞描述："></a>漏洞描述：</h2><p>为了方便的获得网站域名，开发人员一般依赖于HTTP Host header。例如，在php里用_SERVER[“HTTP_HOST”]。但是这个header是不可信赖的，如果应用程序没有对host header值进行处理，就有可能造成恶意代码的传入。</p><a id="more"></a><h2 id="修复方式："><a href="#修复方式：" class="headerlink" title="修复方式："></a>修复方式：</h2><h3 id="一：过滤器"><a href="#一：过滤器" class="headerlink" title="一：过滤器"></a>一：过滤器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line">import javax.servlet.FilterChain;</span><br><span class="line">import javax.servlet.FilterConfig;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import cn.com.do1.component.util.AppConstant;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 防止攻击者替换请求header的host</span><br><span class="line"> * @author hupenghui</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class HostAccessFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">private final static transient Logger logger = LoggerFactory.getLogger(HostAccessFilter.class);</span><br><span class="line"></span><br><span class="line">    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException,</span><br><span class="line">            ServletException &#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line">        // 头攻击检测</span><br><span class="line">        String requestHost=request.getServerName()+<span class="string">":"</span>+request.getServerPort();</span><br><span class="line">        <span class="keyword">if</span> (requestHost != null &amp;&amp; !ServerWhiteListUtil.isWhite(requestHost)) &#123;</span><br><span class="line">            response.setStatus(403);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(req, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">destroy</span></span>() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void init(FilterConfig arg0) throws ServletException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static class ServerWhiteListUtil&#123;</span><br><span class="line"></span><br><span class="line">private static String HOSTS = AppConstant.wx_host_access;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断当前host是否在白名单内</span><br><span class="line">     * @param host 待查host</span><br><span class="line">     * @<span class="built_in">return</span> boolean 是否在白名单内</span><br><span class="line">     */</span><br><span class="line">    public static boolean isWhite(String host) &#123;</span><br><span class="line">    </span><br><span class="line">//    logger.info(<span class="string">"HostAccessFilter "</span>+host+<span class="string">" 获取域名地址"</span>);</span><br><span class="line">     //校验host白名单</span><br><span class="line">     <span class="keyword">if</span> (!HOSTS.contains(host)) &#123;</span><br><span class="line">     </span><br><span class="line">     logger.info(<span class="string">"HostAccessFilter "</span>+host+<span class="string">" 校验host不成功，原因可能是为添加指定的host白名单"</span>);</span><br><span class="line">     <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二：配置nginx获取真实请求的host域名"><a href="#二：配置nginx获取真实请求的host域名" class="headerlink" title="二：配置nginx获取真实请求的host域名"></a>二：配置nginx获取真实请求的host域名</h3><p>nginx反向代理配置时，一般会添加下面的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 在匹配请求地址的时候配置：location / &#123;xxx&#125;</span><br><span class="line">*/</span><br><span class="line">proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">proxy_set_header REMOTE-HOST <span class="variable">$remote_addr</span>;</span><br><span class="line">proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br></pre></td></tr></table></figure><p>其中第一行关于host的配置，是关于域名传递的配置，余下跟IP相关。</p><h3 id="三：设置域名与虚拟主机的绑定"><a href="#三：设置域名与虚拟主机的绑定" class="headerlink" title="三：设置域名与虚拟主机的绑定"></a>三：设置域名与虚拟主机的绑定</h3><p>配置tomcat的server.xml配置文件</p><img src="/2018/09/01/检测到目标URL存在http-host头攻击漏洞/security_hole_1.png" title="配置域名与虚拟主机的绑定"><h3 id="修改jsp中获取项目根路径的方式"><a href="#修改jsp中获取项目根路径的方式" class="headerlink" title="修改jsp中获取项目根路径的方式"></a>修改jsp中获取项目根路径的方式</h3><p>如下图的方式不可取</p><img src="/2018/09/01/检测到目标URL存在http-host头攻击漏洞/security_hole_2.png" title="该获取的方式不可取">]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;漏洞描述：&quot;&gt;&lt;a href=&quot;#漏洞描述：&quot; class=&quot;headerlink&quot; title=&quot;漏洞描述：&quot;&gt;&lt;/a&gt;漏洞描述：&lt;/h2&gt;&lt;p&gt;为了方便的获得网站域名，开发人员一般依赖于HTTP Host header。例如，在php里用_SERVER[“HTTP_HOST”]。但是这个header是不可信赖的，如果应用程序没有对host header值进行处理，就有可能造成恶意代码的传入。&lt;/p&gt;
    
    </summary>
    
      <category term="WEB安全" scheme="http://hupenghui123.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="漏洞" scheme="http://hupenghui123.top/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="WEB安全" scheme="http://hupenghui123.top/tags/WEB%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux下安装tomcat服务器和部署WEB应用</title>
    <link href="http://hupenghui123.top/2018/09/01/Linux%E4%B8%8B%E5%AE%89%E8%A3%85tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E9%83%A8%E7%BD%B2WEB%E5%BA%94%E7%94%A8/"/>
    <id>http://hupenghui123.top/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/</id>
    <published>2018-09-01T11:40:46.000Z</published>
    <updated>2018-09-01T12:24:03.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、上传Tomcat服务器"><a href="#一、上传Tomcat服务器" class="headerlink" title="一、上传Tomcat服务器"></a>一、上传Tomcat服务器</h2><a id="more"></a><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_1.png" title="上传Tomcat服务器"><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_2.png" title="查看是否上传成功"><h2 id="二、安装Tomcat服务器"><a href="#二、安装Tomcat服务器" class="headerlink" title="二、安装Tomcat服务器"></a>二、安装Tomcat服务器</h2><h3 id="2-1、解压tomcat服务器压缩包"><a href="#2-1、解压tomcat服务器压缩包" class="headerlink" title="2.1、解压tomcat服务器压缩包"></a>2.1、解压tomcat服务器压缩包</h3><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_3.png" title="解压tomcat压缩包"><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_4.png" title="查看是否解压成功"><h3 id="2-2、配置环境变量"><a href="#2-2、配置环境变量" class="headerlink" title="2.2、配置环境变量"></a>2.2、配置环境变量</h3><p>tomcat服务器运行时是需要JDK支持的，所以必须配置好JDK用到的那些环境变量</p><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_5.png" title="查看JDK配置文件"><p>编辑/etc下的profile文件，加上如下内容：</p><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_6.png" title="编辑配置文件"><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_7.png" title="编辑配置文件"><h3 id="2-3、修改tomcat服务器的启动端口"><a href="#2-3、修改tomcat服务器的启动端口" class="headerlink" title="2.3、修改tomcat服务器的启动端口"></a>2.3、修改tomcat服务器的启动端口</h3><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_8.png" title="修改tomcat启动端口"><p>修改将Tomcat服务器启动时使用的端口，例如改成9999</p><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_9.png" title="修改tomcat启动端口"><p>修改完server.xml文件之后，保存，退出。</p><h2 id="三、Tomcat服务器启动和关闭"><a href="#三、Tomcat服务器启动和关闭" class="headerlink" title="三、Tomcat服务器启动和关闭"></a>三、Tomcat服务器启动和关闭</h2><h3 id="3-1、启动Tomcat服务器"><a href="#3-1、启动Tomcat服务器" class="headerlink" title="3.1、启动Tomcat服务器"></a>3.1、启动Tomcat服务器</h3><p>进入tomcat服务器的bin目录，然后执行”./startup.sh”命令启动Tomcat服务器，如下图所示：</p><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_10.png" title="启动tomcat服务"><p>查看tomcat服务器的Log信息，看看tomcat服务器是否已经正常启动，进入tomcat服务器下的logs目录，打开catalina.out文件进行查看，如下图所示：</p><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_11.png" title="查看启动日志"><p>访问Tomcat服务器，如下图所示：</p><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_12.png" title="访问tomcat"><p>可以正常访问了，说明Tomcat服务器已经正常启动成功了。</p><p>如果tomcat启动不了，那么最有可能就是启动时使用的端口被其他应用程序占用了，那么可以通过如下的办法进行排查，例如查看9999端口被哪个应用程序占用了。</p><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_13.png" title="查看指定端口的状态"><h3 id="3-2、关闭Tomcat服务器"><a href="#3-2、关闭Tomcat服务器" class="headerlink" title="3.2、关闭Tomcat服务器"></a>3.2、关闭Tomcat服务器</h3><p>进入tomcat服务器的bin目录，然后执行”./shutdown.sh”命令启动Tomcat服务器，如下图所示：</p><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_14.png" title="关闭tomcat服务"><p>查看tomcat服务器的Log信息，看看tomcat服务器是否已经正常关闭，进入tomcat服务器下的logs目录，打开catalina.out文件进行查看，如下图所示：</p><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_15.png" title="查看关闭日志"><h2 id="四、部署JavaWeb应用到Tomcat服务器"><a href="#四、部署JavaWeb应用到Tomcat服务器" class="headerlink" title="四、部署JavaWeb应用到Tomcat服务器"></a>四、部署JavaWeb应用到Tomcat服务器</h2><p>部署JavaWeb应用到Tomcat服务器就是将开放好的JavaWeb应用打包成war包，然后发布到tomcat服务器的webapps目录下</p><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_16.png" title="进入tomcat中的webapps"><h3 id="4-1、打包JavaWeb应用（也可以使用maven的mvn-clean-package）"><a href="#4-1、打包JavaWeb应用（也可以使用maven的mvn-clean-package）" class="headerlink" title="4.1、打包JavaWeb应用（也可以使用maven的mvn clean package）"></a>4.1、打包JavaWeb应用（也可以使用maven的mvn clean package）</h3><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_17.png" title="选择要打成war包的项目"><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_18.png" title="选择war file"><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_19.png" title="项目打包"><p>项目打包成功，如下图所示：</p><img src="/2018/09/01/Linux下安装tomcat服务器和部署WEB应用/Linux_tomcat_20.png" title="war包"><h3 id="4-2、将war包发布到tomcat服务器的webapps目录下"><a href="#4-2、将war包发布到tomcat服务器的webapps目录下" class="headerlink" title="4.2、将war包发布到tomcat服务器的webapps目录下"></a>4.2、将war包发布到tomcat服务器的webapps目录下</h3><p>将JavaWeb应用打包成war包之后，要将这个war包放到tomcat服务器的webapps目录下</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、上传Tomcat服务器&quot;&gt;&lt;a href=&quot;#一、上传Tomcat服务器&quot; class=&quot;headerlink&quot; title=&quot;一、上传Tomcat服务器&quot;&gt;&lt;/a&gt;一、上传Tomcat服务器&lt;/h2&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://hupenghui123.top/categories/Linux/"/>
    
    
      <category term="tomcat" scheme="http://hupenghui123.top/tags/tomcat/"/>
    
      <category term="Linux" scheme="http://hupenghui123.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>nginx静态文件缓存的解决方案</title>
    <link href="http://hupenghui123.top/2018/09/01/nginx%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://hupenghui123.top/2018/09/01/nginx静态文件缓存的解决方案/</id>
    <published>2018-09-01T04:29:38.000Z</published>
    <updated>2018-09-01T09:34:41.491Z</updated>
    
    <content type="html"><![CDATA[<p>nginx的一大功能就是完成静态资源的分离部署，减轻后端服务器的压力，如果给这些静态资源再加一级nginx的缓存，可以进一步提升访问效率。</p><a id="more"></a><h2 id="第一步：添加nginx-conf的http级别的缓存配置（在http-中添加）"><a href="#第一步：添加nginx-conf的http级别的缓存配置（在http-中添加）" class="headerlink" title="第一步：添加nginx.conf的http级别的缓存配置（在http{}中添加）"></a>第一步：添加nginx.conf的http级别的缓存配置（在http{}中添加）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##cache##    </span></span><br><span class="line">proxy_connect_timeout 500;    <span class="comment">#跟后端服务器连接的超时时间_发起握手等候响应超时时间    </span></span><br><span class="line">proxy_read_timeout 600;    <span class="comment">#连接成功后_等候后端服务器响应的时间_其实已经进入后端的排队之中等候处理    </span></span><br><span class="line">proxy_send_timeout 500;    <span class="comment">#后端服务器数据回传时间_就是在规定时间内后端服务器必须传完所有数据   </span></span><br><span class="line">proxy_buffer_size 128k;    <span class="comment">#代理请求缓存区_这个缓存区间会保存用户的头信息以供Nginx进行规则处理_一般只要能保存下头信息即可      </span></span><br><span class="line">proxy_buffers 4 128k;    <span class="comment">#同上 告诉Nginx保存单个用的几个Buffer最大用多大空间    </span></span><br><span class="line">proxy_busy_buffers_size 256k;    <span class="comment">#如果系统很忙的时候可以申请更大的proxy_buffers 官方推荐*2    </span></span><br><span class="line">proxy_temp_file_write_size 128k;    <span class="comment">#proxy缓存临时文件的大小    </span></span><br><span class="line">proxy_temp_path /usr/<span class="built_in">local</span>/nginx/temp;    <span class="comment">#用于指定本地目录来缓冲较大的代理请求    </span></span><br><span class="line">proxy_cache_path /usr/<span class="built_in">local</span>/nginx/cache levels=1:2 keys_zone=cache_one:200m inactive=1d max_size=30g;    <span class="comment">#设置web缓存区名为cache_one,内存缓存空间大小为12000M，自动清除超过15天没有被访问过的缓存数据，硬盘缓存空间大小200g</span></span><br></pre></td></tr></table></figure><p>此处的重点在最后一句，缓存存储路径为：/usr/local/nginx/cache，levels=1:2代表缓存的目录结构为2级目录</p><p>如下图，缓存会在/usr/local/nginx/cache目录下生成，包含2级目录，在之下就是缓存文件，测试的时候可以到该目录下查看缓存文件是否生成。</p><img src="/2018/09/01/nginx静态文件缓存的解决方案/nginx_images_1.png" title="添加nginx.conf的http级别的缓存配置（在http{}中添加）"><h2 id="第二步：在访问静态文件的location上添加缓存"><a href="#第二步：在访问静态文件的location上添加缓存" class="headerlink" title="第二步：在访问静态文件的location上添加缓存"></a>第二步：在访问静态文件的location上添加缓存</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#静态数据保存时效</span></span><br><span class="line">location ~ \.html$ &#123;      </span><br><span class="line">proxy_pass http://source.qingk.cn;      </span><br><span class="line">proxy_redirect off;      </span><br><span class="line">proxy_cache cache_one;      <span class="comment">#此处的cache_one必须于上一步配置的缓存区域名称相同      </span></span><br><span class="line">proxy_cache_valid 200304 12h;      </span><br><span class="line">proxy_cache_valid 301302 1d;      </span><br><span class="line">proxy_cache_valid any 1m;      <span class="comment">#不同的请求设置不同的缓存时效      </span></span><br><span class="line">proxy_cache_key <span class="variable">$uri</span><span class="variable">$is_args</span><span class="variable">$args</span>;      <span class="comment">#生产缓存文件的key，通过4个string变量结合生成      </span></span><br><span class="line">expires 30d;      <span class="comment">#其余类型的缓存时效为30天      </span></span><br><span class="line">proxy_set_header X-Forwarded-Proto <span class="variable">$scheme</span>;&#125;</span><br></pre></td></tr></table></figure><p>此处需要注意3点：</p><p>1、只有在proxy_pass的时候，才会生成缓存，下一次请求执行到proxy_pass的时候会判断是否有缓存，如果有则直接读缓存，返回给客户端，不会执行proxy_pass；如果没有，则执行proxy_pass，并按照规则生成缓存文件；可以到nginx的cache文件夹下看是否生成了缓存文件。</p><p>2、proxy_set_header Host $host 这一句可能导致缓存失败，所以不能配置这一句。我在测试的时候遇到了这个问题，不明原理。</p><p>3、proxy_pass使用upstream出差，换成域名或ip则可行。</p><h2 id="第三步：在proxy-pass跳转的location中配置静态文件的路径"><a href="#第三步：在proxy-pass跳转的location中配置静态文件的路径" class="headerlink" title="第三步：在proxy_pass跳转的location中配置静态文件的路径"></a>第三步：在proxy_pass跳转的location中配置静态文件的路径</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(html)$ &#123;    </span><br><span class="line">default_type <span class="string">'text/html'</span>;    </span><br><span class="line">root <span class="string">"/usr/local/openresty/nginx/html"</span>;&#125;</span><br></pre></td></tr></table></figure><p>将nginx本地存放静态文件的路径配到root指令处</p><p>如果没有这一句：default_type ‘text/html’，所有的请求都默认是下载文件，而不是访问html页面</p><p>到此，静态文件缓存已经配置完成。但是还差很重要的最后一步，缓存生成之后会阻止访问进入后台和nginx本地，如果有更新，则更新内容无法生效，还需要一种手动清除缓存的机制。</p><h2 id="第四步：清除缓存"><a href="#第四步：清除缓存" class="headerlink" title="第四步：清除缓存"></a>第四步：清除缓存</h2><p>缓存文件是根据proxy_cache_key这个指令生成的，所以找到对应的缓存文件，删除即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ /purge(/.*) &#123;    <span class="comment">#删除指定缓存区域cache_one的特定缓存文件$1$is_args$args    proxy_cache_purge cache_one $1$is_args$args;    #运行本机和10.0.217.0网段的机器访问，拒绝其它所有      </span></span><br><span class="line">allow           127.0.0.1;    </span><br><span class="line">allow           10.0.217.0/24;    </span><br><span class="line">deny          all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除缓存用到proxy_cache_purge指令。</p><p>至此缓存生成和特定清除机制都已经实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx的一大功能就是完成静态资源的分离部署，减轻后端服务器的压力，如果给这些静态资源再加一级nginx的缓存，可以进一步提升访问效率。&lt;/p&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://hupenghui123.top/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://hupenghui123.top/tags/nginx/"/>
    
  </entry>
  
</feed>
